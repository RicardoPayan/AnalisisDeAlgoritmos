#Sum (a,n)

a = 0
Sum(a,n){
    s:= 0
    for i:= 1 to n do
        s:= s + a[i]
    return s;
}

#Rsum (a,n)
RSum(a,n){
    if (n<=0) then return 0.0;
    else return RSum(a,n-1) + a[n];
}

#Add (a,b,c,m,n){
    for i:= 1 to m do
        for j:= 1 to n do
            c[i,j]:= a[i,j] + b[i,j];
}

#Fibonacci
Fibonacci(n){
    if(n<=1) then
        write(n);
    else{
        fnm2:=0; fnm1:=1;
        for i:= 2 to n do{
            fn:=fnm1 + fnm2;
            fnm2:= fnm1; fnm1:=fn;
        }
        write(fn);
    }
}

#Transpose
Transpose(a,n){
    for i:= 1 to n-1 do
        for j:= i+1 to n do{
            t:= a[i,j]; a[i,j]:=a[j,i]; a[j,i]:=t;
        }
}

#Mult
Mult(a,b,c,m,n,p){
    for i:= 1 to m do
        for j:= 1 to p do{
            c[i,j]:=0;
            for k:= 1 to n do
                c[i,j]:=c[i,j]+a[i,k]*b[k,j];
        }
}

#Busqueda secuencial
SeqSearch(a,x,n){
    // Search for x in a[1:n]. a[0] is used as additional space.
    i:= n; a[0] := x;
    while (a[i]!=x) do i:= i-1;
    return i;
}

#Busqueda secuencial aleatoria
RSearch(a,x,n){
    while(true) do{
        i:= Random() mod n+1;
        // i is random in the range [1,n]
        if (a[i]=x) then return i;
    }
}

#Busqueda binaria recursiva
BinSrch(a,1,n,x){
    if(n=1) then{
        if (x = a[i]) then return i;
        else return 0;
    }
    else
    {
        //Obtener el piso
        mid:= floor[(i+n)/2] 
        if (x:=a[mid]) then return mid;
        else if (x<a[mid]) then
                return BinSrch(a,i,mid-1,x);
             else return BinSrch(a,mid+1,n,x);      
    }
}

#Busqueda binaria iterativa
BinSearch(a,n,x){
    low:=1; high:=n;
    while(low<=high) do {
        mid:= (low+high)/2;
        if (x < a[mid]) then high := mid-1;
        else if (x > a[mid]) then low := mid+1;
            else return mid;
    }
    return 0;
}

BinSearch2(a,n,x){
    low := 1; high := n + 1;
    while(low < (high - 1)) do {
        mid := (low + high)/2;
        if (x < a[mid]) then high := mid;
        else low := mid;
    }
    if (x = a[low]) then return low;
    else return 0;
}

#Cuadro magico

Magic(n){
    if ((n mod 2) = 0) then {
        write ("n is even"); return;
    }
    else
    {
        for i:=0 to n-1 do //Initialize square to zero
            for j:=0 to n-1 do square[i,j]:=0;
        square[0,(n-1)/2]:=1; // Middle of first row
        // (i,j) is current position
        j:=(n-1)/2;
        for key:= 2 to n^2 do{
            if(i >= 1) then k := i-1; else k := n-1;
            if(j >= 1) then l := j-1; else l := n-1;
            if(square[k,l]>=1) then i:=(i+1) mod n;
            else{
                i := k; j := l;
            }
            square[i,j] := key;
        }
        for i:=0 to n-1 do
            for j:=0 to n-1 do write (square[i,j])
    }
}